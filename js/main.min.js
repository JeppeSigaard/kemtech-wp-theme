var ajaxURL = $('meta[name="ajax-url"]').attr('content');
$('meta[name=ajax-url]').remove();

// @koala-append 'assets/viewport.js';
// @koala-append 'assets/autosize.js';
// @koala-append 'assets/js.cookie.js';
// @koala-append 'assets/styledselect.js';
// @koala-append 'assets/putCursorAtEnd.js';
// @koala-append 'assets/lightbox.js';

// @koala-append 'components/data-img.js';
// @koala-append 'components/form.js';
// @koala-append 'components/is.js';
// @koala-append 'components/jshtml.js';



// @koala-append 'modules/toggle-menu.js';
// @koala-append 'modules/product-search.js';
// @koala-append 'modules/sync-scroll.js';
// @koala-append 'modules/doubletab.js';
// @koala-append 'modules/lightbox-settings.js';
// @koala-append 'modules/data-href.js';

/*
 * Viewport - jQuery selectors for finding elements in viewport
 *
 * Copyright (c) 2008-2009 Mika Tuupola
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 *  http://www.appelsiini.net/projects/viewport
 *
 */
(function($) {
    
    $.belowthefold = function(element, settings) {
        var fold = $(window).height() + $(window).scrollTop();
        return fold <= $(element).offset().top - settings.threshold;
    };

    $.abovethetop = function(element, settings) {
        var top = $(window).scrollTop();
        return top >= $(element).offset().top + $(element).height() - settings.threshold;
    };
    
    $.rightofscreen = function(element, settings) {
        var fold = $(window).width() + $(window).scrollLeft();
        return fold <= $(element).offset().left - settings.threshold;
    };
    
    $.leftofscreen = function(element, settings) {
        var left = $(window).scrollLeft();
        return left >= $(element).offset().left + $(element).width() - settings.threshold;
    };
    
    $.inviewport = function(element, settings) {
        return !$.rightofscreen(element, settings) && !$.leftofscreen(element, settings) && !$.belowthefold(element, settings) && !$.abovethetop(element, settings);
    };
    
    $.extend($.expr[':'], {
        "below-the-fold": function(a, i, m) {
            return $.belowthefold(a, {threshold : 0});
        },
        "above-the-top": function(a, i, m) {
            return $.abovethetop(a, {threshold : 0});
        },
        "left-of-screen": function(a, i, m) {
            return $.leftofscreen(a, {threshold : 0});
        },
        "right-of-screen": function(a, i, m) {
            return $.rightofscreen(a, {threshold : 0});
        },
        "in-viewport": function(a, i, m) {
            return $.inviewport(a, {threshold : 0});
        }
    });

    
})(jQuery);

(function (root, factory) {
	'use strict';

	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.autosize = factory();
  }
}(this, function () {
	function main(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || ta.hasAttribute('data-autosize-on')) { return; }

		var maxHeight;
		var heightOffset;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			// horizontal overflow is hidden, so break-word is necessary for handling words longer than the textarea width
			ta.style.wordWrap = 'break-word';

			// Chrome/Safari-specific fix:
			// When the textarea y-overflow is hidden, Chrome/Safari doesn't reflow the text to account for the space
			// made available by removing the scrollbar. This workaround will cause the text to reflow.
			var width = ta.style.width;
			ta.style.width = '0px';
			// Force reflow:
			/* jshint ignore:start */
			ta.offsetWidth;
			/* jshint ignore:end */
			ta.style.width = width;

			maxHeight = style.maxHeight !== 'none' ? parseFloat(style.maxHeight) : false;

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop)+parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth)+parseFloat(style.borderBottomWidth);
			}

			adjust();
		}

		function adjust() {
			var startHeight = ta.style.height;
			var htmlTop = document.documentElement.scrollTop;
			var bodyTop = document.body.scrollTop;

			ta.style.height = 'auto';

			var endHeight = ta.scrollHeight+heightOffset;

			if (maxHeight !== false && maxHeight < endHeight) {
				endHeight = maxHeight;
				if (ta.style.overflowY !== 'scroll') {
					ta.style.overflowY = 'scroll';
				}
			} else if (ta.style.overflowY !== 'hidden') {
				ta.style.overflowY = 'hidden';
			}

			ta.style.height = endHeight+'px';

			// prevents scroll-position jumping
			document.documentElement.scrollTop = htmlTop;
			document.body.scrollTop = bodyTop;

			if (startHeight !== ta.style.height) {
				var evt = document.createEvent('Event');
				evt.initEvent('autosize.resized', true, false);
				ta.dispatchEvent(evt);
			}
		}

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', adjust);
		}

		window.addEventListener('resize', adjust);
		ta.addEventListener('input', adjust);

		ta.addEventListener('autosize.update', adjust);

		ta.addEventListener('autosize.destroy', function(style){
			window.removeEventListener('resize', adjust);
			ta.removeEventListener('input', adjust);
			ta.removeEventListener('keyup', adjust);
			ta.removeEventListener('autosize.destroy');

			Object.keys(style).forEach(function(key){
				ta.style[key] = style[key];
			});

			ta.removeAttribute('data-autosize-on');
		}.bind(ta, {
			height: ta.style.height,
			overflow: ta.style.overflow,
			overflowY: ta.style.overflowY,
			wordWrap: ta.style.wordWrap,
			resize: ta.style.resize
		}));

		ta.setAttribute('data-autosize-on', true);
		ta.style.overflow = 'hidden';
		ta.style.overflowY = 'hidden';

		init();
	}

	// Do nothing in IE8 or lower
	if (typeof window.getComputedStyle !== 'function') {
		return function(elements) {
			return elements;
		};
	} else {
		return function(elements) {
			if (elements && elements.length) {
				Array.prototype.forEach.call(elements, main);
			} else if (elements && elements.nodeName) {
				main(elements);
			}
			return elements;
		};
	}
}));


/*!
 * Javascript Cookie v1.5.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	var jQuery;
	if (typeof define === 'function' && define.amd) {
		// AMD (Register as an anonymous module)
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// Node/CommonJS
		try {
			jQuery = require('jquery');
		} catch(e) {}
		module.exports = factory(jQuery);
	} else {
		// Browser globals
		var _OldCookies = window.Cookies;
		var api = window.Cookies = factory(window.jQuery);
		api.noConflict = function() {
			window.Cookies = _OldCookies;
			return api;
		};
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return api.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return api.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(api.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return api.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = api.raw ? s : parseCookieValue(s);
		return isFunction(converter) ? converter(value) : value;
	}

	function extend() {
		var key, options;
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			options = arguments[ i ];
			for (key in options) {
				result[key] = options[key];
			}
		}
		return result;
	}

	function isFunction(obj) {
		return Object.prototype.toString.call(obj) === '[object Function]';
	}

	var api = function (key, value, options) {

		// Write

		if (arguments.length > 1 && !isFunction(value)) {
			options = extend(api.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setMilliseconds(t.getMilliseconds() + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {},
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling "get()".
			cookies = document.cookie ? document.cookie.split('; ') : [],
			i = 0,
			l = cookies.length;

		for (; i < l; i++) {
			var parts = cookies[i].split('='),
				name = decode(parts.shift()),
				cookie = parts.join('=');

			if (key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	api.get = api.set = api;
	api.defaults = {};

	api.remove = function (key, options) {
		// Must not alter options, thus extending a fresh object...
		api(key, '', extend(options, { expires: -1 }));
		return !api(key);
	};

	if ( $ ) {
		$.cookie = api;
		$.removeCookie = api.remove;
	}

	return api;
}));


/*
Reference: http://jsfiddle.net/BB3JK/47/
*/

$('select').each(function(){
    var $this = $(this), numberOfOptions = $(this).children('option').length;

    $this.addClass('select-hidden');
    $this.wrap('<div class="select"></div>');
    $this.after('<div class="select-styled"></div>');

    var $styledSelect = $this.next('div.select-styled');
    $styledSelect.text($this.children('option').eq(0).text());

    var $list = $('<ul />', {
        'class': 'select-options'
    }).insertAfter($styledSelect);

    for (var i = 0; i < numberOfOptions; i++) {
        $('<li />', {
            text: $this.children('option').eq(i).text(),
            rel: $this.children('option').eq(i).val()
        }).appendTo($list);
    }

    var $listItems = $list.children('li');

    $styledSelect.click(function(e) {
        e.stopPropagation();
        $(this).parent('.select').next('label').addClass('stayup');

        $('div.select-styled.active').each(function(){
            $(this).removeClass('active').next('ul.select-options').hide();

        });
        $(this).toggleClass('active').next('ul.select-options').toggle();
    });

    $listItems.click(function(e) {
        e.stopPropagation();
        $styledSelect.text($(this).text()).removeClass('active').addClass('success');
        $this.val($(this).attr('rel'));
        $list.hide();
        //console.log($this.val());
    });

    $(document).click(function() {
        $styledSelect.removeClass('active');
        $list.hide();
    });

});


jQuery.fn.putCursorAtEnd = function() {

  return this.each(function() {

    $(this).focus()

    // If this function exists...
    if (this.setSelectionRange) {
      // ... then use it (Doesn't work in IE)

      // Double the length because Opera is inconsistent about whether a carriage return is one character or two. Sigh.
      var len = $(this).val().length * 2;

      this.setSelectionRange(len, len);
    
    } else {
    // ... otherwise replace the contents with itself
    // (Doesn't work in Google Chrome)

      $(this).val($(this).val());
      
    }

    // Scroll to the bottom, in case we're in a tall textarea
    // (Necessary for Firefox and Google Chrome)
    this.scrollTop = 999999;

  });

};

/*!
 * Lightbox v2.8.2
 * by Lokesh Dhakar
 *
 * More info:
 * http://lokeshdhakar.com/projects/lightbox2/
 *
 * Copyright 2007, 2015 Lokesh Dhakar
 * Released under the MIT license
 * https://github.com/lokesh/lightbox2/blob/master/LICENSE
 */

// Uses Node, AMD or browser globals to create a module.
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals (root is window)
        root.lightbox = factory(root.jQuery);
    }
}(this, function ($) {

  function Lightbox(options) {
    this.album = [];
    this.currentImageIndex = void 0;
    this.init();

    // options
    this.options = $.extend({}, this.constructor.defaults);
    this.option(options);
  }

  // Descriptions of all options available on the demo site:
  // http://lokeshdhakar.com/projects/lightbox2/index.html#options
  Lightbox.defaults = {
    albumLabel: 'Image %1 of %2',
    alwaysShowNavOnTouchDevices: false,
    fadeDuration: 500,
    fitImagesInViewport: true,
    // maxWidth: 800,
    // maxHeight: 600,
    positionFromTop: 50,
    resizeDuration: 700,
    showImageNumberLabel: true,
    wrapAround: false,
    disableScrolling: false
  };

  Lightbox.prototype.option = function(options) {
    $.extend(this.options, options);
  };

  Lightbox.prototype.imageCountLabel = function(currentImageNum, totalImages) {
    return this.options.albumLabel.replace(/%1/g, currentImageNum).replace(/%2/g, totalImages);
  };

  Lightbox.prototype.init = function() {
    this.enable();
    this.build();
  };

  // Loop through anchors and areamaps looking for either data-lightbox attributes or rel attributes
  // that contain 'lightbox'. When these are clicked, start lightbox.
  Lightbox.prototype.enable = function() {
    var self = this;
    $('body').on('click', 'a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]', function(event) {
      self.start($(event.currentTarget));
      return false;
    });
  };

  // Build html for the lightbox and the overlay.
  // Attach event handlers to the new DOM elements. click click click
  Lightbox.prototype.build = function() {
    var self = this;
    $('<div id="lightboxOverlay" class="lightboxOverlay"></div><div id="lightbox" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($('body'));

    // Cache jQuery objects
    this.$lightbox       = $('#lightbox');
    this.$overlay        = $('#lightboxOverlay');
    this.$outerContainer = this.$lightbox.find('.lb-outerContainer');
    this.$container      = this.$lightbox.find('.lb-container');

    // Store css values for future lookup
    this.containerTopPadding = parseInt(this.$container.css('padding-top'), 10);
    this.containerRightPadding = parseInt(this.$container.css('padding-right'), 10);
    this.containerBottomPadding = parseInt(this.$container.css('padding-bottom'), 10);
    this.containerLeftPadding = parseInt(this.$container.css('padding-left'), 10);

    // Attach event handlers to the newly minted DOM elements
    this.$overlay.hide().on('click', function() {
      self.end();
      return false;
    });

    this.$lightbox.hide().on('click', function(event) {
      if ($(event.target).attr('id') === 'lightbox') {
        self.end();
      }
      return false;
    });

    this.$outerContainer.on('click', function(event) {
      if ($(event.target).attr('id') === 'lightbox') {
        self.end();
      }
      return false;
    });

    this.$lightbox.find('.lb-prev').on('click', function() {
      if (self.currentImageIndex === 0) {
        self.changeImage(self.album.length - 1);
      } else {
        self.changeImage(self.currentImageIndex - 1);
      }
      return false;
    });

    this.$lightbox.find('.lb-next').on('click', function() {
      if (self.currentImageIndex === self.album.length - 1) {
        self.changeImage(0);
      } else {
        self.changeImage(self.currentImageIndex + 1);
      }
      return false;
    });

    this.$lightbox.find('.lb-loader, .lb-close').on('click', function() {
      self.end();
      return false;
    });
  };

  // Show overlay and lightbox. If the image is part of a set, add siblings to album array.
  Lightbox.prototype.start = function($link) {
    var self    = this;
    var $window = $(window);

    $window.on('resize', $.proxy(this.sizeOverlay, this));

    $('select, object, embed').css({
      visibility: 'hidden'
    });

    this.sizeOverlay();

    this.album = [];
    var imageNumber = 0;

    function addToAlbum($link) {
      self.album.push({
        link: $link.attr('href'),
        title: $link.attr('data-title') || $link.attr('title')
      });
    }

    // Support both data-lightbox attribute and rel attribute implementations
    var dataLightboxValue = $link.attr('data-lightbox');
    var $links;

    if (dataLightboxValue) {
      $links = $($link.prop('tagName') + '[data-lightbox="' + dataLightboxValue + '"]');
      for (var i = 0; i < $links.length; i = ++i) {
        addToAlbum($($links[i]));
        if ($links[i] === $link[0]) {
          imageNumber = i;
        }
      }
    } else {
      if ($link.attr('rel') === 'lightbox') {
        // If image is not part of a set
        addToAlbum($link);
      } else {
        // If image is part of a set
        $links = $($link.prop('tagName') + '[rel="' + $link.attr('rel') + '"]');
        for (var j = 0; j < $links.length; j = ++j) {
          addToAlbum($($links[j]));
          if ($links[j] === $link[0]) {
            imageNumber = j;
          }
        }
      }
    }

    // Position Lightbox
    var top  = $window.scrollTop() + this.options.positionFromTop;
    var left = $window.scrollLeft();
    this.$lightbox.css({
      top: top + 'px',
      left: left + 'px'
    }).fadeIn(this.options.fadeDuration);

    // Disable scrolling of the page while open
    if (this.options.disableScrolling) {
      $('body').addClass('lb-disable-scrolling');
    }

    this.changeImage(imageNumber);
  };

  // Hide most UI elements in preparation for the animated resizing of the lightbox.
  Lightbox.prototype.changeImage = function(imageNumber) {
    var self = this;

    this.disableKeyboardNav();
    var $image = this.$lightbox.find('.lb-image');

    this.$overlay.fadeIn(this.options.fadeDuration);

    $('.lb-loader').fadeIn('slow');
    this.$lightbox.find('.lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption').hide();

    this.$outerContainer.addClass('animating');

    // When image to show is preloaded, we send the width and height to sizeContainer()
    var preloader = new Image();
    preloader.onload = function() {
      var $preloader;
      var imageHeight;
      var imageWidth;
      var maxImageHeight;
      var maxImageWidth;
      var windowHeight;
      var windowWidth;

      $image.attr('src', self.album[imageNumber].link);

      $preloader = $(preloader);

      $image.width(preloader.width);
      $image.height(preloader.height);

      if (self.options.fitImagesInViewport) {
        // Fit image inside the viewport.
        // Take into account the border around the image and an additional 10px gutter on each side.

        windowWidth    = $(window).width();
        windowHeight   = $(window).height();
        maxImageWidth  = windowWidth - self.containerLeftPadding - self.containerRightPadding - 20;
        maxImageHeight = windowHeight - self.containerTopPadding - self.containerBottomPadding - 120;

        // Check if image size is larger then maxWidth|maxHeight in settings
        if (self.options.maxWidth && self.options.maxWidth < maxImageWidth) {
          maxImageWidth = self.options.maxWidth;
        }
        if (self.options.maxHeight && self.options.maxHeight < maxImageWidth) {
          maxImageHeight = self.options.maxHeight;
        }

        // Is there a fitting issue?
        if ((preloader.width > maxImageWidth) || (preloader.height > maxImageHeight)) {
          if ((preloader.width / maxImageWidth) > (preloader.height / maxImageHeight)) {
            imageWidth  = maxImageWidth;
            imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10);
            $image.width(imageWidth);
            $image.height(imageHeight);
          } else {
            imageHeight = maxImageHeight;
            imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10);
            $image.width(imageWidth);
            $image.height(imageHeight);
          }
        }
      }
      self.sizeContainer($image.width(), $image.height());
    };

    preloader.src          = this.album[imageNumber].link;
    this.currentImageIndex = imageNumber;
  };

  // Stretch overlay to fit the viewport
  Lightbox.prototype.sizeOverlay = function() {
    this.$overlay
      .width($(document).width())
      .height($(document).height());
  };

  // Animate the size of the lightbox to fit the image we are showing
  Lightbox.prototype.sizeContainer = function(imageWidth, imageHeight) {
    var self = this;

    var oldWidth  = this.$outerContainer.outerWidth();
    var oldHeight = this.$outerContainer.outerHeight();
    var newWidth  = imageWidth + this.containerLeftPadding + this.containerRightPadding;
    var newHeight = imageHeight + this.containerTopPadding + this.containerBottomPadding;

    function postResize() {
      self.$lightbox.find('.lb-dataContainer').width(newWidth);
      self.$lightbox.find('.lb-prevLink').height(newHeight);
      self.$lightbox.find('.lb-nextLink').height(newHeight);
      self.showImage();
    }

    if (oldWidth !== newWidth || oldHeight !== newHeight) {
      this.$outerContainer.animate({
        width: newWidth,
        height: newHeight
      }, this.options.resizeDuration, 'swing', function() {
        postResize();
      });
    } else {
      postResize();
    }
  };

  // Display the image and its details and begin preload neighboring images.
  Lightbox.prototype.showImage = function() {
    this.$lightbox.find('.lb-loader').stop(true).hide();
    this.$lightbox.find('.lb-image').fadeIn('slow');

    this.updateNav();
    this.updateDetails();
    this.preloadNeighboringImages();
    this.enableKeyboardNav();
  };

  // Display previous and next navigation if appropriate.
  Lightbox.prototype.updateNav = function() {
    // Check to see if the browser supports touch events. If so, we take the conservative approach
    // and assume that mouse hover events are not supported and always show prev/next navigation
    // arrows in image sets.
    var alwaysShowNav = false;
    try {
      document.createEvent('TouchEvent');
      alwaysShowNav = (this.options.alwaysShowNavOnTouchDevices) ? true : false;
    } catch (e) {}

    this.$lightbox.find('.lb-nav').show();

    if (this.album.length > 1) {
      if (this.options.wrapAround) {
        if (alwaysShowNav) {
          this.$lightbox.find('.lb-prev, .lb-next').css('opacity', '1');
        }
        this.$lightbox.find('.lb-prev, .lb-next').show();
      } else {
        if (this.currentImageIndex > 0) {
          this.$lightbox.find('.lb-prev').show();
          if (alwaysShowNav) {
            this.$lightbox.find('.lb-prev').css('opacity', '1');
          }
        }
        if (this.currentImageIndex < this.album.length - 1) {
          this.$lightbox.find('.lb-next').show();
          if (alwaysShowNav) {
            this.$lightbox.find('.lb-next').css('opacity', '1');
          }
        }
      }
    }
  };

  // Display caption, image number, and closing button.
  Lightbox.prototype.updateDetails = function() {
    var self = this;

    // Enable anchor clicks in the injected caption html.
    // Thanks Nate Wright for the fix. @https://github.com/NateWr
    if (typeof this.album[this.currentImageIndex].title !== 'undefined' &&
      this.album[this.currentImageIndex].title !== '') {
      this.$lightbox.find('.lb-caption')
        .html(this.album[this.currentImageIndex].title)
        .fadeIn('fast')
        .find('a').on('click', function(event) {
          if ($(this).attr('target') !== undefined) {
            window.open($(this).attr('href'), $(this).attr('target'));
          } else {
            location.href = $(this).attr('href');
          }
        });
    }

    if (this.album.length > 1 && this.options.showImageNumberLabel) {
      var labelText = this.imageCountLabel(this.currentImageIndex + 1, this.album.length);
      this.$lightbox.find('.lb-number').text(labelText).fadeIn('fast');
    } else {
      this.$lightbox.find('.lb-number').hide();
    }

    this.$outerContainer.removeClass('animating');

    this.$lightbox.find('.lb-dataContainer').fadeIn(this.options.resizeDuration, function() {
      return self.sizeOverlay();
    });
  };

  // Preload previous and next images in set.
  Lightbox.prototype.preloadNeighboringImages = function() {
    if (this.album.length > this.currentImageIndex + 1) {
      var preloadNext = new Image();
      preloadNext.src = this.album[this.currentImageIndex + 1].link;
    }
    if (this.currentImageIndex > 0) {
      var preloadPrev = new Image();
      preloadPrev.src = this.album[this.currentImageIndex - 1].link;
    }
  };

  Lightbox.prototype.enableKeyboardNav = function() {
    $(document).on('keyup.keyboard', $.proxy(this.keyboardAction, this));
  };

  Lightbox.prototype.disableKeyboardNav = function() {
    $(document).off('.keyboard');
  };

  Lightbox.prototype.keyboardAction = function(event) {
    var KEYCODE_ESC        = 27;
    var KEYCODE_LEFTARROW  = 37;
    var KEYCODE_RIGHTARROW = 39;

    var keycode = event.keyCode;
    var key     = String.fromCharCode(keycode).toLowerCase();
    if (keycode === KEYCODE_ESC || key.match(/x|o|c/)) {
      this.end();
    } else if (key === 'p' || keycode === KEYCODE_LEFTARROW) {
      if (this.currentImageIndex !== 0) {
        this.changeImage(this.currentImageIndex - 1);
      } else if (this.options.wrapAround && this.album.length > 1) {
        this.changeImage(this.album.length - 1);
      }
    } else if (key === 'n' || keycode === KEYCODE_RIGHTARROW) {
      if (this.currentImageIndex !== this.album.length - 1) {
        this.changeImage(this.currentImageIndex + 1);
      } else if (this.options.wrapAround && this.album.length > 1) {
        this.changeImage(0);
      }
    }
  };

  // Closing time. :-(
  Lightbox.prototype.end = function() {
    this.disableKeyboardNav();
    $(window).off('resize', this.sizeOverlay);
    this.$lightbox.fadeOut(this.options.fadeDuration);
    this.$overlay.fadeOut(this.options.fadeDuration);
    $('select, object, embed').css({
      visibility: 'visible'
    });
    if (this.options.disableScrolling) {
      $('body').removeClass('lb-disable-scrolling');
    }
  };

  return new Lightbox();
}));


// Load images into placeholders
// Use data-bg="" on any element to async load an image background
// Use data-src="" on images to async load an image src


var loadDataImages = function(){
    
    // For each background placeholder
    $('[data-bg]').each(function(e){
        
            // grab 'this', the data-bg attribute and make a new placeholder image object
            var $img = $(this),
                $imgSrc = $(this).attr('data-bg'),
                $imgPlaceholder = new Image();
            
            // render background into local storage by applying it to the placeholder
            $imgPlaceholder.src = $imgSrc;
            
            // When the placeholder is loaded
            $imgPlaceholder.onload = function(){
                
                // Apply the source to 'this', hide 'this' and fade it in
                $img.removeAttr('data-bg').removeClass('loading').css({
                    backgroundImage: 'url('+$imgSrc+')',
                });
            };
        });
        
    
        // Basically same thing with images
        
        
        $('img[data-src]').each(function(e){
            
            var $img = $(this),
                $imgSrc = $(this).attr('data-src'),
                $imgPlaceholder = new Image();
            
            $imgPlaceholder.src = $imgSrc;
            $imgPlaceholder.onload = function(){
                $img.removeAttr('data-src').removeClass('loading').attr('src',$imgSrc);
            };
        });


}

// Run on load (and use in other scripts as needed)
$(window).on('load',function(){
    loadDataImages();
});


var checkSuccess = function(target){

    if(target.val() === ''){target.removeClass('success').next('label').removeClass('stayup');}

    else if(target.is('input[type="checkbox"], input[type="radio"]')){}

    else{target.addClass('success').next('label').addClass('stayup');}

}

var formHandleResponse = function(response,form){

    form.removeClass('loading');
    
    $.event.trigger({
        type : "formReturn",
        response : response,
        target : form,
    });

}

var validateForm = function(form){

    var ready = true;

    form.find('input').each(function(){

        if($(this).hasClass('error')){
            ready = false;
        }

		if($(this).is(':required') || $(this).hasClass('required') && $(this).val() === ''){
			$(this).removeClass('success').addClass('error');
			ready = false;
		}

    });

    if (ready){
        return true;
    }
    else{
        return false
    }
}

var validateEmail = function(email) {
    var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
    return re.test(email);
}

var formJsInit = function(){

    $('form input, form textarea').each(function(){
        checkSuccess($(this));
    });

    autosize($('form textarea:not(.no-autosize)'));

    // Check for allerede udfyldt felter ved sideload
    $('form input, form textarea').each(function(){
        var target = $(this);
        checkSuccess(target);
    });

    // Kosmetisk opdatering ved blur
    $('form input, form textarea').off().on('blur',function(e){
        var target = $(e.target);

        // Fjern error
        target.removeClass('error');

        // Check om feltet er tomt
        checkSuccess(target);

        if(target.is('input[type="email"]') && target.val() !== ''){

            if(!validateEmail(target.val())){

                target.addClass('error');
            }


        }

    });


    $('form').off().on({

        keyup : function(e){

            var target = $(e.target);

            // Fjern error og success
            target.removeClass('error').removeClass('success');

            if(target.is('input[type="number"]')){

                var value = target.val().replace(/[^0-9]/g, '');

                target.val(value);

            }
            
            if(target.is('input[data-restrict="true"]')){
                
                var value = target.val().replace(/[^0-9a-zA-ZÆØÅæøå ]/g, '');

                target.val(value);
                
            }

        },

        click : function(e){
            var t = $(e.target);

            if(t.is('.submit')){
                e.preventDefault();


                var form = t.parents('form'),
                    action = form.attr('action'),
                    formData = form.serialize();

                if(validateForm(form) && !form.hasClass('loading') && !form.hasClass('success')){

                    form.addClass('loading');

                    $.ajax({
                        url : action,
                        type : 'POST',
                        data : formData,
                        dataType : 'json',
                        success : function(response){
                            formHandleResponse(response,form);
                        },
                    });

                }
            }
        }
     });

}

$(function(){

    formJsInit();

});


function is_mobile(){
    return $('body').hasClass('is-mobile');
};

function is_touch_device() {
  return 'ontouchstart' in window || navigator.maxTouchPoints;
};

function jshtml(tagname,attributes,content){
    var ret = '<' + tagname,
        lineBreaks = false;
    
    if (attributes.lineBreaks === true){
        lineBreaks = true;
    }
    
    for (var k in attributes){
        if (attributes.hasOwnProperty(k) && k !== 'lineBreaks') {
            ret += ' '+ k + '="' +attributes[k]+ '"';   
        }
    }
    
    if(typeof content !== 'undefined'){
    
        if ($.isArray(content)){
            ret +=  '>';
            
            content.forEach(function(e){
                ret += '\n' + e;        
            });
            
            ret += '\n</' + tagname + '>';;
        }
        
        else if (lineBreaks){ret += '>' + content.replace(/(?:\r\n|\r|\n)/g, '<br />') + '</' + tagname + '>';}
        
        else{ ret += '>' + content + '</' + tagname + '>';}
    }

    else{ ret += '/>';}
    
    return ret;
};

$('.header-hamburger').on('click',function(){
    
    $('body').toggleClass('show-menu');
    
});

var prodSearch = {
    
    titles : {},
    data : {},
    
    substringMatcher : function(strs,q) {
        var matches, substringRegex;
        matches = [];
        substrRegex = new RegExp(q, 'i');
        $.each(strs, function(i, str) {
            if (substrRegex.test(str)) {
                matches.push(i);
            }
        });
        return matches;
    },
    
    fetchProducts : function(complete){
        $.ajax({
            url : ajaxURL,
            type : 'POST',
            data : 'action=fetch-products',
            dataType : 'json',
            success : function(response){
                if (response.data){
                    prodSearch.data = response.data;
                    prodSearch.titles = response.titles;
                } 
                if(typeof complete === 'function'){
                    complete(response);
                }
            },
        });
    },
    
    makeNode : function(id,term){
        var data = prodSearch.data[id],
            
            img = jshtml('img',{src: data.img}),
            imgContainer = jshtml('div',{class : 'result-img'},[img]),
            
            header = jshtml('h3',{class: 'result-title',} , prodSearch.strHiglight(data.title, term)),
            desc = jshtml('div',{class: 'result-desc'},prodSearch.strHiglight(data.desc, term));
            
            vars = '';
            data.vars.forEach(function(i){
                vars += jshtml('span',{class: 'result-variation'},i);
            });
            
            var footer = jshtml('footer',{class: 'result-footer'},vars),
            textContainer = jshtml('div',{class: 'result-text'}, [header,desc,footer]),
            
            downloadData = jshtml('div',{class: 'download-link download-data','data-href' : data.downloads.data },'Hent Datablad'),
            downloadApprove = jshtml('div',{class: 'download-link download-approve', 'data-href' : data.downloads.approve},'Hent Godkendelser'),
                
            linksContainer = jshtml('div',{class: 'result-links'},[downloadData,downloadApprove]),
            
            containerInner = jshtml('div',{class: 'inner'}, [imgContainer, textContainer, linksContainer]),
            container = jshtml('a', {class: 'result result-'+id, href: data.permalink} , [containerInner] );
        
        return container;
    },
    
    strHiglight : function(str,hi){
        var substrRegex = new RegExp(hi,'i'),
            ret = str;
        if (substrRegex.test(str)) {
            var ret = str.replace(substrRegex,jshtml( 'span', {class: 'hilight'}, String(str.match(substrRegex))));
        }
        return ret;
    },
    
    keyup : function(){
        if(!$('body').hasClass('is-customizer')){$('#product-search-form input[name="s"]').focus()}
        $('#product-search-form input[name="s"]').on({
            
            keydown : function(e){
                
                if (e.keyCode === 9 && $('.search-results-container .result').length){
                    e.preventDefault();
                    $('.search-results-container .result:first-child').focus();

                }
                
            },
            
            keyup : function(e){
                var content = $(this).val(),
                    resultContainer = $('.search-results-container');
                if(content.length > 2){
                    prodSearch.spawnResults(content,resultContainer);
                }

            }
        });    
    },
    
    spawnResults : function(content,resultContainer){
        
        if(!$('.hero-banner').hasClass('search-mode')){
            $('.hero-banner').addClass('search-mode');
        }

        resultContainer.empty();

        var t = 0,
            maxRes = 10,
            incs = [];

        // Søg på titler
        var titleMatches = prodSearch.substringMatcher(prodSearch.titles,content);
        titleMatches.forEach(function(i){
            t ++;
            if(t < maxRes && incs.indexOf(i) === -1){
                incs.push(parseInt(i));
                resultContainer.append(prodSearch.makeNode(i,content));
            }
        });
        
        // Søg på indhold
        var descriptions = [];
        for (var prop in prodSearch.data) {
            if( prodSearch.data.hasOwnProperty( prop ) ) {
                descriptions[prop] = prodSearch.data[prop].desc;
            } 
        }
        
        var descMatches = prodSearch.substringMatcher(descriptions,content);
        descMatches.forEach(function(i){
            t ++;
            if(t < maxRes && incs.indexOf(i) === -1){
                incs.push(parseInt(i));
                resultContainer.append(prodSearch.makeNode(i,content));
            }
        });
        
        // Søg på langt indhold
        descriptions = [];
        for (var prop in prodSearch.data) {
            if( prodSearch.data.hasOwnProperty( prop ) ) {
                descriptions[prop] = prodSearch.data[prop].long_desc;
            } 
        }
        
        descMatches = prodSearch.substringMatcher(descriptions,content);
        descMatches.forEach(function(i){
            t ++;
            if(t < maxRes && incs.indexOf(i) === -1){
                incs.push(parseInt(i));
                resultContainer.append(prodSearch.makeNode(i,content));
            }
        });
        
        
        // Afslut med en ingen resultater - box, hvis t = 0;
        if(t === 0){
            
            var span = jshtml('span',{},'Din søgning på "'+ content + '" gav ingen resultater.');
            resultContainer.append(jshtml('div',{class: 'search-no-results'},[span]));
        }
        
    },
}

// Do all this on load
$(function(){
    
    if($('#product-search-form').length){
        
        prodSearch.fetchProducts(function(){
            
            if(!is_touch_device()){
                prodSearch.keyup();
            }
            
            if($('input[name=s]').val().length > 2){
                prodSearch.spawnResults($('input[name=s]').val(),$('.search-results-container'));
                $('input[name=s]').putCursorAtEnd();
            }
            
            $('.submit-search').click(function(e){
                e.preventDefault();
                var content = $('input[name=s]').val(),
                    res = $('.search-results-container');
                
                if(content.length > 2 ){
                    prodSearch.spawnResults(content,res);
                }
            });
        });
    }
    
    else{
        
        $('.sidebar-submit-search').click(function(e){
            e.preventDefault();
            var content = $('input[name=s]').val(),
                form = $(this).parents('form'),
                location = form.attr('action');
            if(content.length > 2){
                window.location.href = location + '?s=' + encodeURI(content);
            }
        });
        
    }
});

$(function(){if($('.fixed-aside').length){

    var lastScrollTop = 0,
        fancyScroll = $('.fixed-aside'),
        content = $('.single-content, .archive-content');

    
    
    $(window).on('scroll', function () {

        if(content.offset().top + content.innerHeight() < $(window).scrollTop() + $(window).height()){
            fancyScroll.addClass('bottom');
        }
        
        else{
            
            fancyScroll.removeClass('bottom');
        }

        var st = $(this).scrollTop(),
            diff = st - lastScrollTop,
            scrollStop = $(window).innerHeight() + $(window).scrollTop(),
            fancyHeight = fancyScroll.offset().top + fancyScroll.innerHeight(),
            fancyScrollAmount = fancyScroll.scrollTop() + diff;

        if(fancyScroll.hasClass('bottom')){
        }
        
		else if($(window).width() > 768 && !fancyScroll.hasClass('bottom')){
            fancyScroll.scrollTop(fancyScrollAmount);
		}

		else{
			fancyScroll.scrollTop(0);
		}

		lastScrollTop = st;
    });
    
    $(window).load(function(){
        
        if($('.site-content').innerHeight() < $('.fixed-aside').innerHeight() && $(window).width() > 960){
        
            $('.site-content').css({
                height: $('.fixed-aside').innerHeight(),
            });

        }
        
    });

}});


var limited = $('ul'),
    doubleTabGo = function(e,m){
        var t = $(e.target); 
        if ( t.next('.sub-menu').length && !t.parents('li').hasClass('go') && $(window).width() < 768 ){
            e.preventDefault(); 
            m.find('.go').removeClass('go'); 
            t.parents('li').addClass('go');
        }
    };
	
	limited.each(function(){
        var menu = $(this);
        menu.on({
            touchend : function(e){
                doubleTabGo(e,menu);
            },
            click : function(e){
                doubleTabGo(e,menu);
            },
        }); 
    
    });

lightbox.option({
    'resizeDuration': 200,
    'fadeDuration' : 200,
    'wrapAround': true,
    'showImageNumberLabel' : false,
});

$('[data-href]').click(function(e){
    
    var h = $(this).attr('data-href');
    if(h !== ''){
        e.preventDefault();
        window.location.href = h;
    }
});